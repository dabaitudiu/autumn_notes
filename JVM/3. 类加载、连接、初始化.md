# 三. 类加载、连接、初始化
加载 -> {验证、准备、解析} -> 初始化、使用、卸载

### 1、概述
1. 加载：查找并加载类文件的二进制数据
2. 连接：将已经读入内存的类的二进制数据合并到JVM运行时环境中去，包含如下几个步骤：
    - 验证： 确保被加载的类的正确性
    - 准备： 为类的**静态变量**分配内存，并初始化他们
    - 解析： 把常量池中的符号引用转换成直接引用
3. 初始化：为类的静态变量赋初始值

### 2、类加载要完成的功能
1. 通过类的**全限定名**（不同路径/包下类名可以相同，所以要全限定名）来获取该类的二进制字节流
2. 把二进制字节流转化为方法区的运行时数据结构
3. 在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口

### 3、加载类的方式
1. 最常见的方式：本地文件系统中加载、从jar等归档文件中加载
2. 动态的方式：将java源文件动态编译成class
3. 其他方式：网络下载、从专有数据库中加载等等

### 4、类加载器
JVM自带的加载器有如下几种：
1. 启动类加载器 (Bootstrap ClassLoader)
2. 平台类加载器 (Platform ClassLoader) <- JDK9之后才有的。 JDK8是扩展类加载器
3. 应用程序类加载器 (AppClassLoader), 一般来说我们自己写的类就是用这个加载器加载的
为什么要把JDK8的扩展类加载器去掉？
1. 扩展类加载器主要用于加载ext/lib/文件夹下的jar包，用于扩展。这是不安全的
2. JDK9之后有了[模块化](https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938)

### 5、类加载器的关系
<p align="center">
  <img src="https://github.com/dabaitudiu/autumn_notes/blob/master/images/jvm1.png" width=400/>
</p>

### 6、类加载器说明
1. 启动类加载器：用于加载启动的基础模块类，比如:java.base、java.management、java.xml等等
2. 平台类加载器：用于家在一些平台相关的模块，比如: java.scripting、java.compiler*、java.corba*等等
3. 应用程序类加载器：自己写的类

### 7、双亲委派模型
JVM中的ClassLoader通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器。这里的父子关系是组合而不是继承，工作过程如下：
1. 一个类加载器接受到类加载请求后，首先搜索它的内建加载器定义的所有”具名模块“
2. 如果找到了合适的模块定义，将会使用该加载器来加载
3. 如果class没有在这些加载器定义的具名模块中找到，那么将会委托给父级加载器，直到启动类加载器
4. 如果父级加载器反馈它不能完成加载请求，比如在它的搜索路径下找不到这个类，那子的类加载器才自己来加载
5. 在类路径下找到的类将成为这些加载器的无名模块

双亲委派模型说明
1. 双亲委派模型对于保证Java程序的稳定运作很重要
2. 实现双亲委派的代码在java.lang.ClassLoader的loadClass()方法中，如果自定义类加载器的话，推荐覆盖实现findClass()方法
3. 如果有一个类加载器能加载某个类，称为定义类加载器，所有能成功返回该类的Class的类加载器都被称为初始类加载器
4. 如果没有指定父加载器，默认就是启动加载器
5. 每个类加载器都有自己的命名空间，命名空间由该加载器及其所有父加载器所加载的类构成，不同的命名空间，**可以出现类的全路径名相同的情况**
6. 运行时包由同一个类加载器的类构成，决定两个类是否属于同一个运行时包，不仅要看全路径名是否一样，还要看定义类加载器是否相投。只有属于同一个运行时包的类才能实现相互包内可见

### 8、破坏双亲委派模型
1. 双亲模型有个问题：父加载器无法向下识别子加载器加载的资源。试想如果在核心类中，想要加载一个用户自己编写的类，那么，由于核心类是由启动类加载器加载的，根据双亲委派机制，它无法委派自己的孩子-系统类加载器进行加载。
2. 为了解决这个问题，引入了线程上下文类加载器。可以通过Thread的setContextClassLoader()进行设置
3. 另外一种典型情况就是实现热替换，比如OSGI的模块化热部署，它的类加载器就不再是严格按照双亲委派模型，很多可能就在平级的类加载器中执行了

### 9、类连接主要验证的内容
1. 类文件结构检查： 按照JVM规范规定的类文件结构进行检查
2. 元数据验证：对字节码描述的信息进行语义分析，保证其符合Java语言规范要求
3. 字节码验证：通过对数据流和控制流进行分析，确保程序予以是合法和符合逻辑的。这里主要对方法体进行校验
4. 符号引用验证：对类自身以外的信息，也就是常量池中的各种符号引用，进行匹配校验

### 10、类连接中的解析
1. 所谓解析，就是把常量池中的符号引用转换成直接引用的过程，包括：符号引用：以一组无歧义的符号来描述所医用的目标，与虚拟机的实现无关
2. 直接引用：直接指向目标的指针、相对偏移量、或是能间接定位到目标的句柄，是和虚拟机实现相关的
3. 主要针对：类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符

### 11、类的初始化
1. 类的初始化就是为类的静态变量赋初始值，或者说是执行类构造器<clinit>方法的过程
    - 如果类还没有加载和连接，就先加载和连接
    - 如果类存在父类，且父类没有初始化，就先初始化父类
    - 如果类中存在初始化语句，就依次执行这些初始化语句
    - 如果是接口的话：a) 初始化一个类的时候，并不会先初始化它实现的接口 b)初始化一个接口时，并不会初始化它的父接口 c) 只有当程序首次使用接口里面的变量或者是调用接口方法的时候，才会导致接口初始化