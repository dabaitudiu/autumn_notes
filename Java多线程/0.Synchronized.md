## Synchronized 详解

### 1.Synchronized的作用
一句话说出Synchronized的作用: 能够保证在同一时刻最多只有一个线程执行该段代码，以保证并发安全的效果

### 2. Synchronized的地位
1. Synchronized是Java的关键字，被Java语言原生支持
2. 是最基本的互斥同步手段
3. 是并发编程中的元老级角色

### 3. 不加锁的后果

以下code，执行之后i的值不为20000. 这是因为i++的操作分为3步: (1) 读 (2) 加1 (3) 写. 可能会出现，两个线程都读了同一个值，后结束的进程将前一个进程的值覆盖，导致此轮只加了1
```java
public class MyRunnable implements Runnable {

    static MyRunnable instance = new MyRunnable();
    private int i = 0;

    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("i = " + i);
    }

    @Override
    public void run() {
        for (int j = 0; j <= 10000; j++) i++;
    }

}
```

### 4. Synchronized的两个用法

#### 4-1. 对象锁
包括同步代码块锁(自己指定锁对象 (默认锁对象为this当前实例对象))，和方法锁

##### 同步代码块锁 - 锁对象是this
```java
public class MyRunnable implements Rumnable {
    static MyRunnable instance = new MyRunnable();

    @Override
    public void run() {
        synchronized(this) {
            System.out.println("我是对象锁的代码块, 我叫" + Thread.currentThread().getName());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "运行结束");
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        while (t1.isAlive() || t2.isAlive()) {

        }
        System.out.println("finished");
    } 
}
```
Output:
```
我是对象锁的代码块, 我叫Thread-0
Thread-0运行结束
我是对象锁的代码块, 我叫Thread-1
Thread-1运行结束
```

##### 同步代码块锁 - 锁对象是Object
```java
public class MyRunnable implements Rumnable {
    static MyRunnable instance = new MyRunnable();

    Object lock1 = new Object();
    Object lock2 = new Object();

    @Override
    public void run() {
        synchronized(lock1) {
            System.out.println("我是lock1, 我叫" + Thread.currentThread().getName());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " lock1 运行结束");
        }

        synchronized(lock2) {
            System.out.println("我是lock2, 我叫" + Thread.currentThread().getName());
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "lock2 运行结束");
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        while (t1.isAlive() || t2.isAlive()) {

        }
        System.out.println("finished");
    } 
}
```
Output:
```
我是lock1, 我叫Thread-0
Thread-0 lock1 运行结束
我是lock2, 我叫Thread-0
我是lock1, 我叫Thread-1
Thread-0 lock2 运行结束
Thread-1 lock1运行结束
我是lock2, 我叫Thread-1
Thread-1 lock2运行结束
finished
```

##### 对象锁的方法修饰形式
```java
public class MyRunnable implements Runnable {
    static MyRunnable instance = new MyRunnable();

    public static void main(String[] args) throws Interrupted Exception{
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        while (t1.isAlive() || t2.isAlive()) {

        }

        System.out.println("finished");
    }

    @Override
    public void run() {
        method();
    }

    public synchronized void method() {
        System.out.println("对象锁的方法修饰形式, 我叫" + Thread.currentThread().getName());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }
}
```
Output:
```
对象锁的方法修饰形式, 我叫Thread-0
Thread-0运行结束
对象锁的方法修饰形式, 我叫Thread-1
Thread-1运行结束

```

#### 4-2. 类锁
只Synchronized修饰静态的方法或指定锁为Class对象

- 概念： Java类可能有很多歌对象，但只有1个Class对象
- 本质： 所谓的类锁，不过是Class对象的锁
- 用法:  类锁只能在同一时刻被一个对象拥有

##### 形式1: synchronized加在static方法上
这种与对象锁的方法锁的区别是：如果method前没有static，那么instance1和instance2都可以并行执行method
```java

public class MyRunnable implements Runnable {
    static MyRunnable instance1 = new MyRunnable();
    static MyRunnable instance2 = new MyRunnable();

    @Override
    public void run() {
        method();
    }

    public static synchronized void method() {
        System.out.println("我是类锁的第一种形式：static形式。我叫"+Thread.currentThread().getName());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "运行结束");
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(instance1);
        Thread t2 = new Thread(instance2);
        t1.start();
        t2.start();
        while (t1.isAlive() || t2.isAlive()) {

        }

        System.out.println("finished");
    }

}

```
##### 形式2: synchronized(*.class) 代码块
```java

public class MyRunnable implements Runnable {
    static MyRunnable instance1 = new MyRunnable();
    static MyRunnable instance2 = new MyRunnable();

    @Override
    public void run() {
        try {
            method()
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void method() throws InterruptedException {
        synchronized (MyRunnable.class) {
            System.out.println("类锁的第二种形式：synchronized(*.class)");
            Thread.sleep(3000);
            System.out.println("finished");
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(instance1);
        Thread t2 = new Thread(instance2);
        t1.start();
        t2.start();
        while (t1.isAlive() || t2.isAlive()) {

        }

        System.out.println("finished");
    }

}
```

##### 处理双线程累加问题
###### 原代码：
```java
public class MyRunnable implements Runnable {

    static MyRunnable instance = new MyRunnable();
    private int i = 0;

    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(instance);
        Thread t2 = new Thread(instance);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("i = " + i);
    }

    @Override
    public void run() {
        for (int j = 0; j <= 10000; j++) i++;
    }

}
```

###### Solution 1 (方法锁-普通方法):
```java
@Override
    public synchronized void run() {
        for (int j = 0; j <= 10000; j++) i++;
    }
```
###### Solution 2 (方法锁-代码块):
```java
@Override
    public void run() {
        synchronized (this) {
            for (int j = 0; j <= 10000; j++) i++;
        }
    }
```
###### Solution 3 (类锁):
```java
@Override
    public void run() {
        synchronized (MyRunnable.class) {
            for (int j = 0; j <= 10000; j++) i++;
        }
    }
```

### 5. 多线程访问同步方法的7种情况(面试常考)
1. 两个线程同时访问一个对象的同步方法
2. 两个线程访问的是两个对象的同步方法
3. 两个线程访问的是synchronized的静态方法
4. 同时访问同步方法与非同步方法
5. 访问同一个对象的不同的普通同步方法
6. 同一个对象同时访问静态synchronized和非静态synchronized方法
7. 方法抛出异常后，会释放锁吗

答案：
1. 一个一个生效
2. 同时生效
3. 一个一个生效
4. 同时生效(未加synchronized的其他方法不受到影响)
5. 一个一个生效。同一个实例，两个方法拿到的this是一样的，所以两个方法不能同时运行
6. 同时生效.一个锁是加给class的，一个锁是加给object的
7. 会。抛出异常后，JVM帮助释放锁
