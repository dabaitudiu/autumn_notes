# 12. 锁

## 1. Lock接口
### 1-1. 简介、地位、作用
1. 锁是一种工具,用于控制对共享资源的访问
2. Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同
3. Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的
4. Lock接口最常见的实现类是ReentrantLock
5. 通常情况下，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许并发访问，比如ReadWriteLock里面的ReadLock.
### 1-2. 为什么synchronized不够用？为什么需要Lock?
#### 为什么不够用
1. 效率低：锁的释放情况少，试图获得锁时不能设置超时、不能重度那一个正在试图获得锁的过程
2. 不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的
3. 无法知道是否成功获取到锁
### 1-3. 方法介绍
- Lock中声明了4个方法来获取锁
- lock(),tryLock(),tryLock(long time, TimeUnit unit)和lockInterruptibly()
#### lock()
1. lock()就是最普通的获取锁，如果锁已经被其他线程获取，则进行等待
2. lock不会像synchronized一样在异常时自动释放锁
3. 最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放
4. lock()方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock()就会陷入永久等待
#### tryLock()
1. tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true。否则返回false, 代表获取锁失败
2. 相比于lock，这样的方法显然功能更强大了，我们可以根据是否能获取到锁来决定后续程序的行为
3. 改方法会立即返回，即便在拿不到锁时不会一直等
#### tryLock(long time, TimeUnit unit)
超时就放弃
### 1-4. 可见性保证
略
## 2. 锁的分类
1. 这些分类，是从各种不同角度出发去看的
2. 这些分类并不会互斥的，也就是多个类型可以并存：有可能一个锁同时属于两种类型
3. 比如ReentrantLock既是互斥锁，又是可重入锁
![img](https://github.com/dabaitudiu/autumn_notes/blob/master/images/locks.png)
## 3. 乐观锁和悲观锁
### 3-1. 为什么会诞生非互斥同步锁--互斥同步锁的劣势
#### 互斥同步锁的劣势
1. 阻塞和唤醒带来的性能劣势
2. 永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的线程将永远得不到执行
3. 优先级反转：低优先级线程拿到锁，使得高优先级线程只能等，优先级比低优先级还低
### 3-2. 什么是乐观锁和悲观锁
#### 悲观锁:
1. 如果我不锁住这个资源，别人就回来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问数据，这样就可以确保数据内容万无一失
2. Java中悲观锁的实现就是synchronized和Lock相关类
3. 典型例子：数据库
   - select for update
   
#### 乐观锁
1. 认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象
2. 在更新的时候，去对比在我修改的期间数据有没有被其他人改变过：如果没被改变过，就说明真的是只有我自己在操作，那我就正常去修改数据
3. 如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃。报错、重试等策略
4. 乐观锁的实现一般都是利用CAS算法来实现的
5. 乐观锁的典型例子就是：原子类、并发容器等
6. Git：Git就是乐观锁的典型例子，当我们往远端仓库push的时候，git会检查远端仓库的版本是不是领先于我们现在的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码了，我们的这次提交就失败；如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库.
7. Git不适合用悲观锁，否则公司倒闭。。。。（我在修改代码的时候别人不能提交）

#### 开销对比
- 悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响。
- 相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么小号的资源也会越来越多

#### 各自的使用场景
1. 悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋消耗，典型情况：
   - 临界区有IO操作
   - 临界区代码复杂或者循环量大
   - 临界区竞争非常激烈
2. 乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高


## 4. 可重入锁和非可重入锁，以ReentrantLock为例(重点)
1. 普通用法1：预定电影院座位
2. 普通用法2：打印字符串
可重入：避免死锁、提升封装性
![img](https://github.com/dabaitudiu/autumn_notes/blob/master/images/reen.png)
## 5. 公平锁和非公平锁
#### 什么是公平非公平
- 公平指的是按照线程请求的顺序来分配锁；非公平指的是不完全按照请求的顺序，在一定情况下，可以插队
- 注意：非公平也同样不提倡“插队”行为，这里的非公平，指的是“在合适的时机”插队，而不是盲目插队
- 什么是合适的时机？
#### 为什么要有非公平锁
为了提高效率，避免唤醒带来的空档期
#### 公平的情况(以ReentrantLock为例)
如果在创建ReentrantLock对象时，参数填为true，那么这就是个公平锁
#### 不公平的情况(以ReentrantLock为例)
线程1释放锁的时候，线程5恰好去执行lock()。由于ReentrantLock发现此时并没有线程持有Lock这把锁（线程2）还没来得及获取到，因为获取需要时间。线程5可以插队，直接拿到这把锁，这也是ReentrantLock默认的公平策略，也就是“不公平”
#### 对比
![img](https://github.com/dabaitudiu/autumn_notes/blob/master/images/eq.png)
![img](https://github.com/dabaitudiu/autumn_notes/blob/master/images/eqs.png)
## 6. 共享锁和排它锁:以ReentrantReadWriteLock读写锁为例
#### 什么是共享锁和排它锁
- 排它锁，又称为独占锁。独享锁
- 共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据
- 共享锁和排它锁的典型是读写锁ReentrantReadWriteLock, 其中读锁是共享锁，写锁是独享锁
#### 读写锁的作用
- 在没有读写锁之前，我们假设使用ReentrantLock, 那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题
- 在读的地方使用读锁，在写的地方使用写锁，灵活控制。如果没有写锁的情况下，读是无阻塞的，提高了程序的运行效率
#### 读写锁的规则
1. 多个线程只申请读锁，都可以申请到
2. 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
3. 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁

#### ReentrantReadWriteLock具体用法
#### 读锁和写锁的交互方式




## 7. 自旋锁和阻塞锁
## 8. 可中断锁
## 9. 锁优化