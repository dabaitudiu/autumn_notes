# 一. 进程、线程

## 一、 进程、线程区别
1. 资源
进程拥有自己的完整的资源平台（程序代码、数据、PC、Register、系统资源），线程只独享必不可少的资源，比如寄存器、栈
2. 调度
线程是CPU独立调度的基本单位，同一进程中的线程切换不会引起进程切换，一个线程切换到另一个进程中的线程时会引起进程切换
3. 开销
在创建和回收进程时，系统要为其分配和回收内存空间、IO设备等等，开销交大。进程切换时，要保存上下文(CPU环境设置等)，而现场只要保存和设置少量寄存器内容，开销小。
4. 通信
同一进程间线程可以相互通信，但进程间通信需要借助IPC

## 二、进程内存结构、线程结构
[参考](https://www.cnblogs.com/jingyg/p/5069964.html)
1. 文本段：程序的机器码。设置为只读，因为多个进程可能使用同一个程序。
2. 初始化数据段：初始化之后的静态变量、全局变量
3. BSS段： 未初始化的全局变量和静态变量。
4. 栈：动态增长和收缩的段，由栈帧组组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量、实参和返回值。（向下增长）
5. 堆：可在运行时为变量分配内存的一块区域。（向上增长）

### 线程结构
- 一个标准的线程由线程id、程序计数器(PC)、寄存器集合和栈组成。
- 每个线程类似一个独立进程，不同的是线程之间共享地址空间，能够访问到相同的数据。线程之间共享进程的内存空间(包括代码段、数据段、堆等)以及以下进程级的资源(如打开文件和信号)

## 三、协程
- 协程可以理解为一个用户态下的线程，在用户态下进行线程（协程）的上下文切换。但是和传统的线程不同的是：线程是抢占式执行，当发生系统调用或者中断的时候，交由OS调度执行；而协程是通过yield主动让出cpu所有权，切换到其他协程执行。
- 有栈协程就是实现了一个用户态的线程，用户可以在堆上模拟出协程的栈空间，当需要进行协程上下文切换的时候，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态就可以实现一个用户态的线程上下文切换，没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效。
一个python协程的例子:
```python
def consume():
    while True:
        number = yield
        print("consuming ", number)

consumer = consume()
# 让初始化状态的consumer协程先执行起来，在yield处停止
next(consumer)
for num in range(0, 100):
    print("producing ", num)
    # 发送数据给consumer协程
    consumer.send(num)
```
代码中创建了一个叫做consumer的协程，并且在主线程中生产数据，协程中消费数据。其中 **yield** 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。但是，yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。因此，协程的开销远远小于线程的开销。

### 为什么协程切换的代价比线程切换低?
[参考链接](https://www.zhihu.com/question/308641794/answer/572499202)
先说结论：协程切换比线程切换快主要有两点：
- 1）协程切换完全在用户空间进行，线程切换涉及特权模式切换，需要在内核空间完成；
- 2）协程切换相比线程切换做的事情更少。
协程切换只涉及基本的CPU上下文切换，所谓的 CPU 上下文，就是一堆寄存器，里面保存了 CPU运行任务所需要的信息：

    - 从哪里开始运行
    - 当前栈帧在哪
    - 栈顶的位置
    - 中间状态
线程切换，除了要将用户态切换到内核态，还要设计线程私有的栈和寄存器等等。

## 四、进程调度算法
[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B)
### 4-1、批处理系统
批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
1. FCFS 先来先得
    - 有利于长作业，短作业有可能要等到很长时间才能被执行
2. SJF 短作业优先
    - 有利于短作业，长作业有可能被饿死
3. SRTM 最短剩余时间
    - SJF的抢占式版本
### 4-2、交互式系统
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。
1. 轮询
将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。要处理好时间片的大小。
2. 优先级调度
为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
3. 多级反馈队列
一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

## 五、进程间通信方式
1. 管道
    - 单向、先进先出、固定大小字节流
    - 数据从输出端读出后，其他进程不能再读到这些数据
    - 简单的流控制：进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。
    - 无名管道：数据单向流动，只能在父子进程间使用
    - 命名管道：在文件系统中作为一个特殊的设备文件而存在，允许无亲缘关系的进程间通信
2. 信号量：计数器，控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及统一进程不同线程之间的同步手段。
3. 消息队列：由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能传输无格式字节流的缺点
    - 块式存储
    - 可以有选择的取出消息，不必先进先出
    - 避免了同步阻塞问题，不需要进程自己提供同步方法
4. 信号
    - 暂时先理解为类似于线程的wait和notify
5. 共享内存: 共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。
6. socket: 套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。

## 六、管程
1. 目的：分离互斥和条件同步的
2. 什么是管程：管程是包含了一系列共享变量，以及针对这些变量进行同步操作的函数模块
    - 包含了锁：指定临界区
    - 0或很多条件变量： 等待、通知

