# 8. CPU调度

## 1. 背景
#### 上下文切换
- 切换CPU的当前任务，从一个进程/线程到另一个
- 保存当前进程/线程在PCB/TCP中执行上下文（CPU状态）
- 读取下一个进程/线程的上下文
#### CPU调度
- 从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个线程/进程
- 调度程序：挑选进程/线程的内核函数（通过一些调度策略）
- 什么时候进行调度？
#### 内核运行调度程序的条件（满足一条即可）
- 一个进程从运行状态切换到等待状态
- 一个进程被终结了
#### 不可抢占
- 调度程序必须等待事件结束
#### 可以抢占
- 调度程序在中断被响应后执行
- 当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪
- 当前运行的进程可以被换出

## 2. 调度准则
### 2-1. 调度策略
#### 执行模型：程序在CPU突发和I/O中交替
- 每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU
- 在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU
#### 评价指标
- CPU使用率：CPU处于忙状态所占时间的百分比
- 吞吐量：在单位时间内完成的进程数量
- 周转时间：一个进程从初始化到结束，包括所有等待时间所花费的时间
- 等待时间：进程在就绪队列的总时间
- 响应时间：从一个请求被提交到产生第一次响应所花费的总时间
总的来说，就是**高带宽，低延迟**
#### 预期效果
- 减少响应时间：及时处理用户的输出并且尽快将输出提供给用户
- 减少平均响应时间的波动：在交互系统中，可预测性比高低差异低平均更重要
- 增加吞吐量：减少开销（OS开销，上下文切换）、系统资源高效利用（CPU,I/O设备）
- 减少等待时间（减少每个进程的等待时间）
#### 效果
1. 低延迟调度增加了交互式表现
   - 如果移动了鼠标，但是屏幕中的光标却没懂，我可能会重启电脑
2. 但是操作系统需要保证吞吐量不收银箱
   - 我想要结束长时间的编程，所以操作系统必须不时进行调度，即使存在许多交互任务
3. 吞吐量时操作系统的计算带宽
4. 响应时间是操作系统的计算延迟
#### 公平的定义
- 保证每个进程占用相同的CPU时间。这公平吗？如果一个用户运行更多的进程呢？
- 保证每个进程都等待相同的时间，如何？
- 公平通常会增加平均响应时间


## 3. 调度算法
#### FCFS （先到先得）
- First Come, First Served
![img](https://github.com/dabaitudiu/autumn_notes/blob/master/images/fifo.png)
##### 优点
简单
##### 缺点
- 平均等待时间波动较大
- 花费时间少的任务可能排在花费时间长的任务后面
- 可能导致I/O和CPU之间的重叠处理（CPU密集型进程会导致I/O设备闲置时，I/O密集型进程也在等待）
#### SPN(SJF) SRT （短进程/短作业/短剩余时间优先）
- Shortest Process Next (Shortest Job First) Shortest Remaining Time
![img](https://github.com/dabaitudiu/autumn_notes/blob/master/images/1.png)

- SPN: 按照预测的完成时间将任务入队
- 可以是可抢占的或者不可抢占的。
- SRT：可抢占： 最短剩余时间
- 最优平均等待时间

##### 缺点
1. 可能导致饥饿
- 连续的短任务流会使长任务饥饿
- 短任务可用的任何长任务的CPU时间都会增加平均等待时间
2. 需要预知未来
- 怎么预估下一个CPU突发的持续时间
- 简单的解决办法：询问用户
- 如果用户欺骗就杀死进程
- 如果用户不知道怎么办

#### HRRN （最高响应比优先）
- Highest Response Ratio Next
- 在SPN调度的基础上改进
- 不可抢占
- 关注进程等待了多长时间
- 防止无限期推迟

#### Round Robin （轮循）
- 使用时间切片和抢占来轮流执行任务
- 花销：额外的上下文切换
- 时间量子太大—>等待时间过长->极限情况退化成FCFS
- 时间量子太小->反应迅速->吞吐量由于大量的上下文切换开销受到影响
- 目标：选择一个合适的时间量子，经验规则：维持上下文切换开销处于1%以内

#### Multilevel Feedback Queues （多级反馈队列）
- 优先级队列中的轮循
1. 就绪队列被划分成独立的队列
E.g. 前台（交互）， 后台（批处理）
2. 每个队列拥有自己的调度策略
E.g. 前台-RR, 后台FCFS
3. 调度必须在队列间进行
- 固定优先级：先处理前台，后处理后台，可能导致饥饿
- 时间切片：每个队列都得到一个确定的能够调度其进程的CPU总时间
- E.g. 80% 给使用RR的前台，20%给使用FCFS的后台

一个进程可以在不同的队列中移动，例如：你级优先级-优先级调度在所有级别中，RR在每个级别中
- 时间量子大小随优先级级别增加而增加
- 如果任务在当前时间的量子中没有完成，则降到下一个优先级
- 优点：CPU密集型任务的优先级下降很快，I/O密集型任务停留在高优先级

#### Fair Share Scheduling （公平共享调度）
- 一些用户比其他用户组更重要
- 保证不重要的组无法垄断资源
- 未使用的资源按照每个组所分配的资源的比例来分配
- 没有达到资源使用率目标的组获得更高的优先级

## 4. 实时调度

### 4-1. 实时系统
### 4-2. 可调度性
### 4-3. 单调速率(RM)
### 4-4. 截止日期最早优先(EDF)

## 5. 多处理器调度

## 6. 优先级反转