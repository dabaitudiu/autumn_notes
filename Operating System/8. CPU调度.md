# 8. CPU调度

## 1. 背景
#### 上下文切换
- 切换CPU的当前任务，从一个进程/线程到另一个
- 保存当前进程/线程在PCB/TCP中执行上下文（CPU状态）
- 读取下一个进程/线程的上下文
#### CPU调度
- 从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个线程/进程
- 调度程序：挑选进程/线程的内核函数（通过一些调度策略）
- 什么时候进行调度？
#### 内核运行调度程序的条件（满足一条即可）
- 一个进程从运行状态切换到等待状态
- 一个进程被终结了
#### 不可抢占
- 调度程序必须等待事件结束
#### 可以抢占
- 调度程序在中断被响应后执行
- 当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪
- 当前运行的进程可以被换出

## 2. 调度准则
### 2-1. 调度策略
#### 执行模型：程序在CPU突发和I/O中交替
- 每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU
- 在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU
#### 评价指标
- CPU使用率：CPU处于忙状态所占时间的百分比
- 吞吐量：在单位时间内完成的进程数量
- 周转时间：一个进程从初始化到结束，包括所有等待时间所花费的时间
- 等待时间：进程在就绪队列的总时间
- 响应时间：从一个请求被提交到产生第一次响应所花费的总时间
总的来说，就是**高带宽，低延迟**
#### 预期效果
- 减少响应时间：及时处理用户的输出并且尽快将输出提供给用户
- 减少平均响应时间的波动：在交互系统中，可预测性比高低差异低平均更重要
- 增加吞吐量：减少开销（OS开销，上下文切换）、系统资源高效利用（CPU,I/O设备）
- 减少等待时间（减少每个进程的等待时间）
#### 效果
1. 低延迟调度增加了交互式表现
   - 如果移动了鼠标，但是屏幕中的光标却没懂，我可能会重启电脑
2. 但是操作系统需要保证吞吐量不收银箱
   - 我想要结束长时间的编程，所以操作系统必须不时进行调度，即使存在许多交互任务
3. 吞吐量时操作系统的计算带宽
4. 响应时间是操作系统的计算延迟
#### 公平的定义
- 保证每个进程占用相同的CPU时间。这公平吗？如果一个用户运行更多的进程呢？
- 保证每个进程都等待相同的时间，如何？
- 公平通常会增加平均响应时间


## 3. 调度算法
#### FCFS （先到先得）
- First Come, First Served
#### SPN(SJF) SRT （短进程/短作业/短剩余时间优先）
- Shortest Process Next (Shortest Job First) Shortest Remaining Time
#### HRRN （最高响应比优先）
- Highest Response Ratio Next
#### Round Robin （轮循）
- 使用时间切片和抢占来轮流执行任务
#### Multilevel Feedback Queues （多级反馈队列）
- 优先级队列中的轮循
#### Fair Share Scheduling （公平共享调度）




## 4. 实时调度

## 5. 多处理器调度

## 6. 优先级反转