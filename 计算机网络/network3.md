# HTTP/HTTPS
[参考: HTTPS系列干货（一）：HTTPS 原理详解](https://www.zhihu.com/collection/205709687?page=2)
## 为什么需要HTTPS
HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击。客户端发出的请求(比如：GET /pic/image1.png HTTP/1.1)很容易被黑客截获，如果黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉. 以 HTTP 传输面临的风险有：
- （1） 窃听风险：黑客可以获知通信内容。
- （2） 篡改风险：黑客可以修改通信内容。
- （3） 冒充风险：黑客可以冒充他人身份参与通信。
如果我们用密钥加密，就可以提升安全性。加密有两种：对称加密和非对称加密。对称加密是指，两者用同一密钥加密解密；非对称加密是指，每个端都有自己的公钥私钥，传输前用对方的公钥加密，对方收到后会用自己的私钥解密。对称加密和非对称加密需要搭配使用更主要的原因是：
- 1）对称加密：两边需要使用相同的密钥，需要使用一种安全的方式交换密钥，单纯使用对称加密，无法实现密钥交换。
- 2）非对称加密：只使用非对称加密是可以满足安全性要求的，但是由于非对称加密的计算耗时高于对称加密的2-3个数量级（相同安全加密级别），所以才先使用非对称交换密钥，之后再使用对称加密通信。
所以流程是：
1. C -> S: 请求公钥
2. S -> C: 返回公钥
3. C -> S: 用公钥将对称加密的密钥发出
4. S -> C: 收到密钥
5. C -> S: 发出被对称密钥加密的内容
6. S: 用对称加密的密钥解密内容
但是这样第2步存在一个问题，黑客有可能冒充server返回了一个公钥。所以这里用到了**SSL证书**。第2步服务器会发送一个SSL证书给客户端，客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验。SSL证书中包含的具体内容有：

    - （1）证书的发布机构CA
    - （2）证书的有效期
    - （3）公钥
    - （4）证书所有者
    - （5）签名
server会将data计算hash， 然后用私钥加密成签名，和证书打包成CA证书发给client。client收到后，会对签名用公钥进行解密，同时会对data用相同的hash计算，比较解密出来的内容是否和hash计算后的一样。如果不一样，就代表认证失败
#### 为什么这可以保证server不是伪造的？
公钥是由CA机构规定的，改变不了。假设有个黑客冒充Amazon，截获到client的信息后，只能用自己的私钥加密，但是client会用amazon的公钥进行解密，所以信息肯定是错误的。

## HTTP/1.0, 1.1, 2.0
- HTTP/1.0: 短连接
- HTTP/1.1: 默认长连接，支持流水线，增加了新的状态码405 Method Not Allowed (DELETE, PUT, TRACE等)
- HTTP/2.0: 
    - 多路复用&二进制分帧：客户端可以在同一个 TCP 连接中同时发送多个请求，然后服务端也可以同时响应多个请求，而不需要按序响应。每一组请求和响应，都会绑定到一个数据流，这个数据流会有个唯一的ID来标识。然后数据流内的请求和响应就会被切分成多个帧，在对每个帧进行二进制编码，同时这个帧会携带数据流的ID，那么客户端或者服务端就可以通过这个ID来判断新到达的帧是属于哪个数据流的。
    - 首部压缩：HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。
    - 服务端推送：HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。