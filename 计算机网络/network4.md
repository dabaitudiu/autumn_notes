# TCP连接的可靠性


## 一、重传机制
- [参考](https://zhuanlan.zhihu.com/p/133307545)
- [参考2: 计算机网络微课堂第070讲 TCP超时重传时间的选择](https://www.bilibili.com/video/BV1s7411q7cn/?spm_id_from=333.788.videocard.0)
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。TCP 会在以下两种情况发生超时重传：数据包丢失/确认应答丢失
- 那么，超时时间应该设置为多少呢？
    - 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；
    - 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。
精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。
- 根据上述的两种情况，我们可以得知，**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**。
然而，不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。
- 实际上，根据RFC推荐，利用每次测量得到的RTT样本，计算加权平均往返时间RTTs。

<p align="center">
  <img src="https://github.com/dabaitudiu/autumn_notes/blob/master/images/network2.png" width=400/>
</p>

- RFC6298建议如下公式计算超时重传时间RTO:

<p align="center">
  <img src="https://github.com/dabaitudiu/autumn_notes/blob/master/images/network3.png" width=400/>
</p>

然而，实际情况RTT很难准确测量。如果发送方发送的第一个数据包未能到达/未能及时到达，重传后的数据包被ACK了，这时发送方不知道是ACK第一次发送的还是第二次发送的。如果误认为是ACK第一次发送的，就会使得RTT偏大。
- 针对出现超时重传时无法测准往返时间RTT的问题，Karn提出了一个算法：在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。
    - 这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了许多，并且之后很长一段时间都会保持这种时延。因此，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新，这会导致报文段反复被重传。
- 因此，要对Karn算法进行修正。方法是：报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是将新RTO的值取为旧RTO值的2倍。


## 二、滑动窗口
- TCP基于以字节为单位的滑动窗口来实现可靠传输

## 三、流量控制
- 一般来说，我们总是希望数据传输的更快一些
    - 但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。
- 所谓流量控制，久石让发送方的发送速率不要太快，要让接收方来得及接收。
- 利用滑动窗口机制，可以很方便地在TCP连接上实现对发送方的流量控制。

## 四、拥塞控制
[参考:计算机网络微课堂第069讲 TCP的拥塞控制](https://www.bilibili.com/video/BV1kJ41177r8?from=search&seid=13137016821778413738)
1. 拥塞：在某段时间，若对某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做拥塞(congestion)。带宽、缓存等都是网络资源。
2. 若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降。吞吐量是指对网络、设备等单位时间内成功地传送数据的数量

### 拥塞控制流程
1. 发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化
    - 拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要出现网络拥塞，拥塞窗口就减少一些
    - 判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发生超时重传）
2. 发送方将拥塞窗口作为发送窗口swnd，即swnd = cwnd
3. 维护一个慢开始门限ssthresh状态变量：
    - 当cwnd < ssthresh时，使用慢开始算法；
    - 当cwnd > ssthresh时，改用拥塞避免算法；
4. 流程：
    - 慢开始：拥塞窗口1 -> 2 -> 4 -> 8 -> 16 （随传输轮次变化）
    - 拥塞避免：16 -> 17 -> 18 -> ... -> 24 发生超时重传
    - 将sshthresh值更新为发生拥塞时cwnd的一半，重新开始慢开始算法
5. 改进:
    - 有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。
        - 这将导致发送方超时重传，并误认为网络发生了拥塞
        - 发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率
    - 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。
    - 所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。
        - 要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发送确认；
        - 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认
    - 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等报文段的超时重传计时器超时再重传。
    - 发送方一旦收到3个连续的重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法。
    - 发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法。
        - 也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3
        - 这3个报文段不再消耗网络资源而是停留在网络资源而是停留在接收方的接收缓存中；
        - 可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把拥塞窗口扩大些
